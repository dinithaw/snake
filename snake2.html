<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Snake ‚Äì Touch & Keyboard</title>
  <style>
    :root{
      --bg: #0f1226;
      --panel: #171a33;
      --bright: #e6e6f0;
      --accent: #6ee7ff;
      --accent2: #8fff8f;
      --danger: #ff6b6b;
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -10%, #1b1f46 0%, #0b0e20 60%, #080a18 100%);
      color: var(--bright);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      overscroll-behavior: none;
      touch-action: none; /* Prevent browser swipe navigation on mobile */
    }

    .wrap {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      align-items: center;
      justify-items: center;
      gap: 12px;
      padding: clamp(12px, 2vmin, 24px);
    }

    header{
      display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap;
    }
    .title { font-weight: 800; letter-spacing: 0.5px; font-size: clamp(18px, 2.8vmin, 22px); opacity: .95; }
    .pill { background: rgba(255,255,255,0.06); padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.08); }

    .hud {
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 8px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
    }
    .hud .label{opacity:.8; font-weight:600; letter-spacing:.3px}
    .hud .val{font-weight:800}

    canvas {
      display:block;
      width: min(92vmin, 640px);
      height: min(92vmin, 640px);
      background: linear-gradient(180deg, #0f1226 0%, #10142a 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 22px 50px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.05);
      touch-action: none; /* ensure touch events reach us */
    }

    .footer {
      opacity:.8; font-size: 12px; text-align:center; line-height:1.4; padding-bottom: 8px;
    }

    .btns{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:center; align-items:center;
    }
    button{
      appearance: none;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--bright);
      padding: 10px 14px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: transform .08s ease, filter .2s ease;
    }
    button:hover{ filter: brightness(1.1); }
    button:active{ transform: translateY(1px) scale(.99); }
    .primary{ border-color: rgba(110,231,255,.6); box-shadow: 0 0 0 3px rgba(110,231,255,.15) inset; }

    /* On-screen swipe hint (mobile) */
    .hint { font-size: 12px; opacity:.7; text-align:center; }

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="pill title">üêç Snake ‚Äì Touch & Keyboard</div>
      <div class="hud">
        <div class="label">Score:&nbsp;</div><div id="score" class="val">0</div>
        <div class="label" style="margin-left:12px">Best:&nbsp;</div><div id="best" class="val">0</div>
        <div class="label" style="margin-left:12px">Speed:&nbsp;</div><div id="speed" class="val">1x</div>
      </div>
    </header>

    <canvas id="game" width="640" height="640" aria-label="Snake game area" role="img"></canvas>

    <div class="btns">
      <button id="startBtn" class="primary">Start / Restart</button>
      <button id="pauseBtn">Pause</button>
      <button id="muteBtn">Mute</button>
    </div>

    <div class="hint">Swipe on the board (‚Üë ‚Üì ‚Üê ‚Üí) on phones ‚Ä¢ Use Arrow Keys / WASD on desktop ‚Ä¢ Press Space to pause</div>

    <div class="footer">Made with HTML, CSS & JavaScript. No libs. Works offline.</div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ==== Game Config ====
    const GRID = 20;              // number of cells per row/col
    const BASE_SPEED = 5.0;       // cells per second at start
    const SPEED_STEP = 0.25;      // speed increase per food
    const MAX_SPEED = 16;         // cap
    const START_LEN = 3;

    // Colors
    const COLORS = {
      gridA: '#121633',
      gridB: '#10122b',
      snakeHead: '#8fff8f',
      snakeBody: '#56d856',
      food: '#6ee7ff',
      text: '#e6e6f0',
      shadow: 'rgba(0,0,0,0.25)'
    };

    // SFX (tiny beep via WebAudio)
    const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
    let muted = false;
    function beep(freq=440, dur=0.06, type='square'){
      if (!audioCtx || muted) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = 0.035;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); setTimeout(() => { o.stop(); o.disconnect(); g.disconnect(); }, dur*1000);
    }

    // ==== Responsive Canvas (pixel-perfect) ====
    function fitCanvas(){
      const size = Math.min(window.innerWidth*0.92, window.innerHeight*0.62* (window.innerWidth<700?1.35:1));
      const cssSize = Math.min(Math.max(360, size), 640); // clamp CSS size
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.style.width = canvas.style.height = cssSize + 'px';
      canvas.width = Math.round(cssSize * dpr);
      canvas.height = Math.round(cssSize * dpr);
      cell = Math.floor(canvas.width / GRID);
      offset = Math.floor((canvas.width - cell*GRID)/2);
    }

    let cell = 0, offset = 0; // computed by fitCanvas
    fitCanvas();
    addEventListener('resize', fitCanvas);

    // ==== Game State ====
    let snake, dir, nextDir, food, speed, tickAcc, running, paused, score, best;

    function reset(){
      const mid = Math.floor(GRID/2);
      snake = [];
      for(let i=0;i<START_LEN;i++) snake.push({x: mid - i, y: mid});
      dir = {x:1, y:0};
      nextDir = {x:1, y:0};
      speed = BASE_SPEED;
      tickAcc = 0;
      running = true; paused = false; score = 0;
      food = spawnFood();
      updateHUD();
    }

    function spawnFood(){
      while(true){
        const f = { x: Math.floor(Math.random()*GRID), y: Math.floor(Math.random()*GRID) };
        if (!snake || !snake.some(s => s.x===f.x && s.y===f.y)) return f;
      }
    }

    function updateHUD(){
      document.getElementById('score').textContent = score;
      best = Math.max(best || 0, score);
      localStorage.setItem('snake_best', best);
      document.getElementById('best').textContent = best;
      const mult = (speed/BASE_SPEED).toFixed(2).replace(/\.00$/,'');
      document.getElementById('speed').textContent = mult + 'x';
    }

    // ==== Input Handlers ====
    function setDirection(nx, ny){
      // prevent reversing into itself
      if (nx === -dir.x && ny === -dir.y) return;
      nextDir = {x:nx, y:ny};
    }

    // Keyboard
    addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (["arrowup","arrowdown","arrowleft","arrowright"," ","w","a","s","d"].includes(k) || k === ' ') e.preventDefault();
      if (k==='arrowup' || k==='w') setDirection(0,-1);
      else if (k==='arrowdown' || k==='s') setDirection(0,1);
      else if (k==='arrowleft' || k==='a') setDirection(-1,0);
      else if (k==='arrowright' || k==='d') setDirection(1,0);
      else if (k===' ') togglePause();
    }, {passive:false});

    // Touch (swipe)
    let touchStart = null;
    const SWIPE_THRESHOLD = 18; // px

    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length>1) return; // ignore multi-touch
      const t = e.touches[0];
      touchStart = {x:t.clientX, y:t.clientY};
    }, {passive:true});

    canvas.addEventListener('touchmove', (e) => {
      if (!touchStart) return;
      const t = e.touches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;
      if (Math.abs(dx) > Math.abs(dy)) {
        setDirection(dx>0 ? 1 : -1, 0);
      } else {
        setDirection(0, dy>0 ? 1 : -1);
      }
      touchStart = null; // only one direction per swipe
    }, {passive:true});

    canvas.addEventListener('touchend', () => { touchStart = null; }, {passive:true});

    // Buttons
    document.getElementById('startBtn').addEventListener('click', () => { if (!running) { reset(); } else { reset(); } });
    document.getElementById('pauseBtn').addEventListener('click', () => togglePause());
    document.getElementById('muteBtn').addEventListener('click', () => { muted = !muted; document.getElementById('muteBtn').textContent = muted? 'Unmute':'Mute'; });

    function togglePause(){ if (!running) return; paused = !paused; if (!paused && audioCtx && audioCtx.state==='suspended') audioCtx.resume(); }

    // ==== Game Loop (fixed-step based on speed) ====
    let last = performance.now();
    function loop(now){
      const dt = Math.min(100, now - last) / 1000; // seconds, clamp to avoid big jumps
      last = now;

      if (running && !paused){
        tickAcc += dt * speed; // cells per second ‚Üí cells progressed
        while (tickAcc >= 1){
          tick();
          tickAcc -= 1;
        }
      }

      draw();
      requestAnimationFrame(loop);
    }

    function tick(){
      dir = nextDir;
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // wrap around edges (toroidal). Change to game over on wall by uncommenting below.
      if (head.x < 0) head.x = GRID-1; else if (head.x >= GRID) head.x = 0;
      if (head.y < 0) head.y = GRID-1; else if (head.y >= GRID) head.y = 0;

      // self collision
      if (snake.some(seg => seg.x===head.x && seg.y===head.y)){
        gameOver();
        return;
      }

      snake.unshift(head);

      // food check
      if (head.x === food.x && head.y === food.y){
        score += 1; speed = Math.min(MAX_SPEED, speed + SPEED_STEP); updateHUD();
        beep(660, .06, 'square');
        food = spawnFood();
      } else {
        snake.pop();
      }
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // grid background
      for (let y=0;y<GRID;y++){
        for (let x=0;x<GRID;x++){
          const gx = offset + x*cell;
          const gy = offset + y*cell;
          ctx.fillStyle = ((x+y)&1) ? COLORS.gridA : COLORS.gridB;
          ctx.fillRect(gx, gy, cell-1, cell-1);
        }
      }

      // food
      drawCell(food.x, food.y, COLORS.food, true);

      // snake
      for (let i=snake.length-1;i>=0;i--){
        const seg = snake[i];
        const isHead = i===0;
        drawCell(seg.x, seg.y, isHead? COLORS.snakeHead : COLORS.snakeBody, false, isHead);
      }

      // overlay messages
      if (!running){
        banner('Tap/Click Start to play');
      } else if (paused){
        banner('Paused');
      }
    }

    function drawCell(x, y, color, isFood=false, head=false){
      const gx = offset + x*cell;
      const gy = offset + y*cell;
      const pad = Math.max(2, Math.floor(cell*0.08));
      const size = cell - pad*2;

      // shadow
      ctx.fillStyle = COLORS.shadow;
      ctx.fillRect(gx+2, gy+2, size, size);

      // body/food
      ctx.fillStyle = color;
      ctx.fillRect(gx+pad, gy+pad, size, size);

      if (isFood){
        // sparkle dot
        ctx.fillStyle = 'rgba(255,255,255,.8)';
        ctx.fillRect(gx+pad+Math.floor(size*0.65), gy+pad+Math.floor(size*0.18), Math.max(1,Math.floor(size*0.08)), Math.max(1,Math.floor(size*0.08)));
      }

      if (head){
        // simple eye
        ctx.fillStyle = '#0b0e20';
        const es = Math.max(1, Math.floor(size*0.12));
        ctx.fillRect(gx+pad+Math.floor(size*0.2), gy+pad+Math.floor(size*0.2), es, es);
      }
    }

    function banner(text){
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(canvas.width/2 - 180, canvas.height/2 - 36, 360, 72);
      ctx.fillStyle = 'rgba(255,255,255,.2)';
      ctx.fillRect(canvas.width/2 - 180, canvas.height/2 - 36, 360, 1);
      ctx.fillRect(canvas.width/2 - 180, canvas.height/2 + 36, 360, 1);
      ctx.font = `${Math.floor(canvas.width*0.03)}px system-ui, sans-serif`;
      ctx.fillStyle = COLORS.text;
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      ctx.restore();
    }

    function gameOver(){
      running = false;
      beep(180, .12, 'sawtooth'); setTimeout(()=>beep(140, .18, 'sawtooth'), 90);
      banner('Game Over ‚Äì Start to try again');
    }

    // Load best score
    best = parseInt(localStorage.getItem('snake_best')||'0',10) || 0;
    document.getElementById('best').textContent = best;

    // Start in idle state
    running = false; paused = false; score = 0; updateHUD();
    snake = [{x:9,y:10},{x:8,y:10},{x:7,y:10}]; dir = nextDir = {x:1,y:0}; food = {x: 14, y:10};

    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
